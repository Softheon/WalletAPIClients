/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "ms-rest-js";
import * as Models from "./models";
import * as Mappers from "./models/mappers";
import { SoftheonWalletAPIContext } from "./softheonWalletAPIContext";
const WebResource = msRest.WebResource;

class SoftheonWalletAPI extends SoftheonWalletAPIContext {
  serializer = new msRest.Serializer(Mappers);

  /**
   * @class
   * Initializes a new instance of the SoftheonWalletAPI class.
   * @constructor
   *
   * @param {string} [baseUri] - The base URI of the service.
   *
   * @param {object} [options] - The parameter options
   *
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   *
   * @param {object} [options.requestOptions] - The request options. Detailed info can be found at
   * {@link https://github.github.io/fetch/#Request Options doc}
   *
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   *
   */
  constructor(baseUri?: string, options?: msRest.ServiceClientOptions) {
    super(baseUri, options);
  }
  // methods on the client.

  /**
   * @summary Gets the bank account associated with the specified token.
   *
   * @param {string} token The token.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getBankAccountByTokenWithHttpOperationResponse(token: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.BankAccountModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          token
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/bankaccounts/{token}",
          urlParameters: [
            {
              parameterPath: "token",
              mapper: {
                required: true,
                serializedName: "token",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: Mappers.BankAccountModel
            },
            401: {},
            403: {},
            404: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.BankAccountModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets all bank accounts associated with the specified reference identifier.
   *
   * @param {string} referenceId The reference identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getBankAccountsByReferenceIdWithHttpOperationResponse(referenceId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.BankAccountModel[]>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          referenceId
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/bankaccounts",
          queryParameters: [
            {
              parameterPath: "referenceId",
              mapper: {
                required: true,
                serializedName: "referenceId",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                  name: "Sequence",
                  element: {
                    serializedName: "BankAccountModelElementType",
                    type: {
                      name: "Composite",
                      className: "BankAccountModel"
                    }
                  }
                }
              }
            },
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = {
              serializedName: "parsedResponse",
              type: {
                name: "Sequence",
                element: {
                  serializedName: "BankAccountModelElementType",
                  type: {
                    name: "Composite",
                    className: "BankAccountModel"
                  }
                }
              }
            };
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a bank account.
   *
   * @param {UpdateBankAccountModel} updateBankAccountModel The update bank account model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async updateBankAccountWithHttpOperationResponse(updateBankAccountModel: Models.UpdateBankAccountModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          updateBankAccountModel
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "PUT",
          baseUrl: this.baseUri,
          path: "payments/v2/bankaccounts",
          requestBody: {
            parameterPath: "updateBankAccountModel",
            mapper: {
              ...Mappers.UpdateBankAccountModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            204: {},
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Posts a new bank account.
   *
   * @param {BankAccountRequestModel} bankAccountRequest The bank account.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async createBankAccountWithHttpOperationResponse(bankAccountRequest: Models.BankAccountRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.BankAccountResponseModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          bankAccountRequest
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/bankaccounts",
          requestBody: {
            parameterPath: "bankAccountRequest",
            mapper: {
              ...Mappers.BankAccountRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            200: {
              bodyMapper: Mappers.BankAccountResponseModel
            },
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.BankAccountResponseModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets the bin information for a specified credit card number.
   *
   * @param {BinRequestModel} binRequest The bin request.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getBinWithHttpOperationResponse(binRequest: Models.BinRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.Bin>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          binRequest
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/bins",
          requestBody: {
            parameterPath: "binRequest",
            mapper: {
              ...Mappers.BinRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            200: {
              bodyMapper: Mappers.Bin
            },
            401: {},
            404: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.Bin;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets the checkout.
   *
   * @param {number} checkoutId The checkout identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getCheckoutWithHttpOperationResponse(checkoutId: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.CheckoutResponseModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          checkoutId
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/checkouts",
          queryParameters: [
            {
              parameterPath: "checkoutId",
              mapper: {
                required: true,
                serializedName: "checkoutId",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: Mappers.CheckoutResponseModel
            },
            401: {},
            404: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.CheckoutResponseModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Posts the specified model.
   *
   * @param {CheckoutRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async createCheckoutWithHttpOperationResponse(model: Models.CheckoutRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.CheckoutResponseModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          model
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/checkouts",
          requestBody: {
            parameterPath: "model",
            mapper: {
              ...Mappers.CheckoutRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            201: {
              bodyMapper: Mappers.CheckoutResponseModel
            },
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 201) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.CheckoutResponseModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets all credit cards associated with the specified reference identifier.
   *
   * @param {string} referenceId The reference identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getCreditCardsByReferenceIdWithHttpOperationResponse(referenceId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.CreditCardModel[]>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          referenceId
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/creditcards",
          queryParameters: [
            {
              parameterPath: "referenceId",
              mapper: {
                required: true,
                serializedName: "referenceId",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                  name: "Sequence",
                  element: {
                    serializedName: "CreditCardModelElementType",
                    type: {
                      name: "Composite",
                      className: "CreditCardModel"
                    }
                  }
                }
              }
            },
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = {
              serializedName: "parsedResponse",
              type: {
                name: "Sequence",
                element: {
                  serializedName: "CreditCardModelElementType",
                  type: {
                    name: "Composite",
                    className: "CreditCardModel"
                  }
                }
              }
            };
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a credit card.
   *
   * @param {UpdateCreditCardModel} updateCreditCardModel The update credit card model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async updateCreditCardWithHttpOperationResponse(updateCreditCardModel: Models.UpdateCreditCardModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          updateCreditCardModel
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "PUT",
          baseUrl: this.baseUri,
          path: "payments/v2/creditcards",
          requestBody: {
            parameterPath: "updateCreditCardModel",
            mapper: {
              ...Mappers.UpdateCreditCardModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            204: {},
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Posts a new credit card.
   *
   * @param {CreditCardRequestModel} creditCardRequest The new credit card.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async createCreditCardWithHttpOperationResponse(creditCardRequest: Models.CreditCardRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.CreditCardResponseModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          creditCardRequest
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/creditcards",
          requestBody: {
            parameterPath: "creditCardRequest",
            mapper: {
              ...Mappers.CreditCardRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            200: {
              bodyMapper: Mappers.CreditCardResponseModel
            },
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.CreditCardResponseModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets the specified payment by its identifier.
   *
   * @param {number} id The payment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getPaymentWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.PaymentModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          id
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/payments/{id}",
          urlParameters: [
            {
              parameterPath: "id",
              mapper: {
                required: true,
                serializedName: "id",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: Mappers.PaymentModel
            },
            401: {},
            404: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.PaymentModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets payments associated with the specified reference identifier.
   *
   * @param {SoftheonWalletAPIGetPaymentsByReferenceIdOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getPaymentsByReferenceIdWithHttpOperationResponse(options?: Models.SoftheonWalletAPIGetPaymentsByReferenceIdOptionalParams): Promise<msRest.HttpOperationResponse<Models.PaymentModel[]>> {
    let referenceId = (options && options.referenceId !== undefined) ? options.referenceId : undefined;
    let minDate = (options && options.minDate !== undefined) ? options.minDate : undefined;
    let maxDate = (options && options.maxDate !== undefined) ? options.maxDate : undefined;

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          referenceId,
          minDate,
          maxDate
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/payments",
          queryParameters: [
            {
              parameterPath: "referenceId",
              mapper: {
                serializedName: "referenceId",
                type: {
                  name: "String"
                }
              }
            },
            {
              parameterPath: "minDate",
              mapper: {
                serializedName: "minDate",
                type: {
                  name: "DateTime"
                }
              }
            },
            {
              parameterPath: "maxDate",
              mapper: {
                serializedName: "maxDate",
                type: {
                  name: "DateTime"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                  name: "Sequence",
                  element: {
                    serializedName: "PaymentModelElementType",
                    type: {
                      name: "Composite",
                      className: "PaymentModel"
                    }
                  }
                }
              }
            },
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = {
              serializedName: "parsedResponse",
              type: {
                name: "Sequence",
                element: {
                  serializedName: "PaymentModelElementType",
                  type: {
                    name: "Composite",
                    className: "PaymentModel"
                  }
                }
              }
            };
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Posts a new payment.
   *
   * @param {PaymentRequestModel} paymentRequest The new payment.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async createPaymentWithHttpOperationResponse(paymentRequest: Models.PaymentRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.PaymentModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          paymentRequest
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/payments",
          requestBody: {
            parameterPath: "paymentRequest",
            mapper: {
              ...Mappers.PaymentRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            201: {
              bodyMapper: Mappers.PaymentModel
            },
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 201) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.PaymentModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets the refunds associated with the specified payment.
   *
   * @param {number} id The identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getRefundsWithHttpOperationResponse(id: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.RefundResultModel[]>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          id
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/payments/{id}/refunds",
          urlParameters: [
            {
              parameterPath: "id",
              mapper: {
                required: true,
                serializedName: "id",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                  name: "Sequence",
                  element: {
                    serializedName: "RefundResultModelElementType",
                    type: {
                      name: "Composite",
                      className: "RefundResultModel"
                    }
                  }
                }
              }
            },
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = {
              serializedName: "parsedResponse",
              type: {
                name: "Sequence",
                element: {
                  serializedName: "RefundResultModelElementType",
                  type: {
                    name: "Composite",
                    className: "RefundResultModel"
                  }
                }
              }
            };
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Posts a new refund request.
   *
   * @param {number} id The identifier of the payment to be refunded.
   *
   * @param {RefundRequestModel} refundRequestModel The refund model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async createRefundWithHttpOperationResponse(id: number, refundRequestModel: Models.RefundRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.RefundResultModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          id,
          refundRequestModel
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/payments/{id}/refunds",
          urlParameters: [
            {
              parameterPath: "id",
              mapper: {
                required: true,
                serializedName: "id",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          requestBody: {
            parameterPath: "refundRequestModel",
            mapper: {
              ...Mappers.RefundRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            200: {
              bodyMapper: Mappers.RefundResultModel
            },
            401: {},
            404: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.RefundResultModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets a single payment subscription with the specified subscription id.
   *
   * @param {string} id The subscription id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getSubscriptionWithHttpOperationResponse(id: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.SubscriptionModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          id
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/subscriptions/{id}",
          urlParameters: [
            {
              parameterPath: "id",
              mapper: {
                required: true,
                serializedName: "id",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: Mappers.SubscriptionModel
            },
            401: {},
            404: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.SubscriptionModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets all payment subscriptions associated with the specified reference id.
   *
   * @param {string} referenceId The reference identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getSubscriptionsByReferenceIdWithHttpOperationResponse(referenceId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.SubscriptionModel[]>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          referenceId
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/subscriptions",
          queryParameters: [
            {
              parameterPath: "referenceId",
              mapper: {
                required: true,
                serializedName: "referenceId",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                  name: "Sequence",
                  element: {
                    serializedName: "SubscriptionModelElementType",
                    type: {
                      name: "Composite",
                      className: "SubscriptionModel"
                    }
                  }
                }
              }
            },
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = {
              serializedName: "parsedResponse",
              type: {
                name: "Sequence",
                element: {
                  serializedName: "SubscriptionModelElementType",
                  type: {
                    name: "Composite",
                    className: "SubscriptionModel"
                  }
                }
              }
            };
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Updates a payment subscription.
   *
   * @param {UpdateSubscriptionModel} updateSubscriptionModel The update subscription model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async updateSubscriptionWithHttpOperationResponse(updateSubscriptionModel: Models.UpdateSubscriptionModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          updateSubscriptionModel
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "PUT",
          baseUrl: this.baseUri,
          path: "payments/v2/subscriptions",
          requestBody: {
            parameterPath: "updateSubscriptionModel",
            mapper: {
              ...Mappers.UpdateSubscriptionModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            204: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Posts a new payment subscription.
   *
   * @param {SubscriptionRequestModel} subscriptionRequest The subscription request.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async createSubscriptionWithHttpOperationResponse(subscriptionRequest: Models.SubscriptionRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.SubscriptionResponseModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          subscriptionRequest
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/subscriptions",
          requestBody: {
            parameterPath: "subscriptionRequest",
            mapper: {
              ...Mappers.SubscriptionRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            200: {
              bodyMapper: Mappers.SubscriptionResponseModel
            },
            400: {},
            401: {},
            409: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.SubscriptionResponseModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets the wallet by wallet ID
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getWalletWithHttpOperationResponse(walletId: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.WalletModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          walletId
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/wallet/{walletId}",
          urlParameters: [
            {
              parameterPath: "walletId",
              mapper: {
                required: true,
                serializedName: "walletId",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: Mappers.WalletModel
            },
            400: {},
            401: {},
            404: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.WalletModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Puts the wallet.
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {string} defaultPaymentToken The default payment token.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async updateWalletWithHttpOperationResponse(walletId: number, defaultPaymentToken: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          walletId,
          defaultPaymentToken
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "PUT",
          baseUrl: this.baseUri,
          path: "payments/v2/wallet/{walletId}",
          urlParameters: [
            {
              parameterPath: "walletId",
              mapper: {
                required: true,
                serializedName: "walletId",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          requestBody: {
            parameterPath: "defaultPaymentToken",
            mapper: {
              required: true,
              serializedName: "defaultPaymentToken",
              type: {
                name: "String"
              }
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            200: {},
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Gets the wallet by reference ID
   *
   * @param {string} referenceId The reference identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async getWalletByReferenceIdWithHttpOperationResponse(referenceId: string, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.WalletModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          referenceId
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "GET",
          baseUrl: this.baseUri,
          path: "payments/v2/wallet",
          queryParameters: [
            {
              parameterPath: "referenceId",
              mapper: {
                required: true,
                serializedName: "referenceId",
                type: {
                  name: "String"
                }
              }
            }
          ],
          responses: {
            200: {
              bodyMapper: Mappers.WalletModel
            },
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.WalletModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Creates a new empty wallet
   *
   * @param {WalletRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async createWalletWithHttpOperationResponse(model: Models.WalletRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<number>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          model
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/wallet",
          requestBody: {
            parameterPath: "model",
            mapper: {
              ...Mappers.WalletRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            200: {
              bodyMapper: {
                serializedName: "parsedResponse",
                type: {
                  name: "Number"
                }
              }
            },
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = {
              serializedName: "parsedResponse",
              type: {
                name: "Number"
              }
            };
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Adds a new credit card to the wallet
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {WalletCreditCardRequestModel} request The request.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async addWalletCreditCardWithHttpOperationResponse(walletId: number, request: Models.WalletCreditCardRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.WalletModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          walletId,
          request
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/wallet/{walletId}/CreditCard",
          urlParameters: [
            {
              parameterPath: "walletId",
              mapper: {
                required: true,
                serializedName: "walletId",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          requestBody: {
            parameterPath: "request",
            mapper: {
              ...Mappers.WalletCreditCardRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            200: {
              bodyMapper: Mappers.WalletModel
            },
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.WalletModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Adds a new bank account to the wallet
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {WalletBankAccountRequestModel} request The request.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async addWalletBankAccountWithHttpOperationResponse(walletId: number, request: Models.WalletBankAccountRequestModel, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<Models.WalletModel>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          walletId,
          request
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "POST",
          baseUrl: this.baseUri,
          path: "payments/v2/wallet/{walletId}/BankAccount",
          urlParameters: [
            {
              parameterPath: "walletId",
              mapper: {
                required: true,
                serializedName: "walletId",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          requestBody: {
            parameterPath: "request",
            mapper: {
              ...Mappers.WalletBankAccountRequestModel,
              required: true
            }
          },
          contentType: "application/json; charset=utf-8",
          responses: {
            200: {
              bodyMapper: Mappers.WalletModel
            },
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
      // Deserialize Response
      let statusCode = operationRes.status;
      if (statusCode === 200) {
        let parsedResponse = operationRes.parsedBody as { [key: string]: any };
        try {
          if (parsedResponse != undefined) {
            const resultMapper = Mappers.WalletModel;
            operationRes.parsedBody = this.serializer.deserialize(resultMapper, parsedResponse, 'operationRes.parsedBody');
          }
        } catch (error) {
          let deserializationError = new msRest.RestError(`Error ${error} occurred in deserializing the responseBody - ${operationRes.bodyAsText}`);
          deserializationError.request = msRest.stripRequest(httpRequest);
          deserializationError.response = msRest.stripResponse(operationRes);
          return Promise.reject(deserializationError);
        }
      }
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes the wallet bank account.
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {number} walletBankAcctId The wallet bank acct identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async removeWalletBankAccountWithHttpOperationResponse(walletId: number, walletBankAcctId: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          walletId,
          walletBankAcctId
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "DELETE",
          baseUrl: this.baseUri,
          path: "payments/v2/wallet/{walletId}/BankAccount/{walletBankAcctId}",
          urlParameters: [
            {
              parameterPath: "walletId",
              mapper: {
                required: true,
                serializedName: "walletId",
                type: {
                  name: "Number"
                }
              }
            },
            {
              parameterPath: "walletBankAcctId",
              mapper: {
                required: true,
                serializedName: "walletBankAcctId",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {},
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }
  // methods on the client.

  /**
   * @summary Deletes the wallet credit card.
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {number} walletCreditCardId The wallet credit card identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  async removeWalletCreditCardWithHttpOperationResponse(walletId: number, walletCreditCardId: number, options?: msRest.RequestOptionsBase): Promise<msRest.HttpOperationResponse<void>> {

    // Create HTTP transport objects
    const httpRequest = new WebResource();
    let operationRes: msRest.HttpOperationResponse;
    try {
      const operationArguments: msRest.OperationArguments = msRest.createOperationArguments(
        {
          walletId,
          walletCreditCardId
        },
        options);
      operationRes = await this.sendOperationRequest(
        httpRequest,
        operationArguments,
        {
          httpMethod: "DELETE",
          baseUrl: this.baseUri,
          path: "payments/v2/wallet/{walletId}/CreditCard/{walletCreditCardId}",
          urlParameters: [
            {
              parameterPath: "walletId",
              mapper: {
                required: true,
                serializedName: "walletId",
                type: {
                  name: "Number"
                }
              }
            },
            {
              parameterPath: "walletCreditCardId",
              mapper: {
                required: true,
                serializedName: "walletCreditCardId",
                type: {
                  name: "Number"
                }
              }
            }
          ],
          responses: {
            200: {},
            400: {},
            401: {},
            default: {}
          },
          serializer: this.serializer
        });
    } catch (err) {
      return Promise.reject(err);
    }
    return Promise.resolve(operationRes);
  }

  /**
   * @summary Gets the bank account associated with the specified token.
   *
   * @param {string} token The token.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.BankAccountModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.BankAccountModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getBankAccountByToken(token: string): Promise<Models.BankAccountModel>;
  getBankAccountByToken(token: string, options: msRest.RequestOptionsBase): Promise<Models.BankAccountModel>;
  getBankAccountByToken(token: string, callback: msRest.ServiceCallback<Models.BankAccountModel>): void;
  getBankAccountByToken(token: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.BankAccountModel>): void;
  getBankAccountByToken(token: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.BankAccountModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.BankAccountModel>;
    if (!callback) {
      return this.getBankAccountByTokenWithHttpOperationResponse(token, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.BankAccountModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getBankAccountByTokenWithHttpOperationResponse(token, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.BankAccountModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets all bank accounts associated with the specified reference identifier.
   *
   * @param {string} referenceId The reference identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.BankAccountModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getBankAccountsByReferenceId(referenceId: string): Promise<Models.BankAccountModel[]>;
  getBankAccountsByReferenceId(referenceId: string, options: msRest.RequestOptionsBase): Promise<Models.BankAccountModel[]>;
  getBankAccountsByReferenceId(referenceId: string, callback: msRest.ServiceCallback<Models.BankAccountModel[]>): void;
  getBankAccountsByReferenceId(referenceId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.BankAccountModel[]>): void;
  getBankAccountsByReferenceId(referenceId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.BankAccountModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.BankAccountModel[]>;
    if (!callback) {
      return this.getBankAccountsByReferenceIdWithHttpOperationResponse(referenceId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.BankAccountModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getBankAccountsByReferenceIdWithHttpOperationResponse(referenceId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.BankAccountModel[];
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Updates a bank account.
   *
   * @param {UpdateBankAccountModel} updateBankAccountModel The update bank account model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  updateBankAccount(updateBankAccountModel: Models.UpdateBankAccountModel): Promise<void>;
  updateBankAccount(updateBankAccountModel: Models.UpdateBankAccountModel, options: msRest.RequestOptionsBase): Promise<void>;
  updateBankAccount(updateBankAccountModel: Models.UpdateBankAccountModel, callback: msRest.ServiceCallback<void>): void;
  updateBankAccount(updateBankAccountModel: Models.UpdateBankAccountModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  updateBankAccount(updateBankAccountModel: Models.UpdateBankAccountModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.updateBankAccountWithHttpOperationResponse(updateBankAccountModel, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateBankAccountWithHttpOperationResponse(updateBankAccountModel, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Posts a new bank account.
   *
   * @param {BankAccountRequestModel} bankAccountRequest The bank account.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.BankAccountResponseModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.BankAccountResponseModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  createBankAccount(bankAccountRequest: Models.BankAccountRequestModel): Promise<Models.BankAccountResponseModel>;
  createBankAccount(bankAccountRequest: Models.BankAccountRequestModel, options: msRest.RequestOptionsBase): Promise<Models.BankAccountResponseModel>;
  createBankAccount(bankAccountRequest: Models.BankAccountRequestModel, callback: msRest.ServiceCallback<Models.BankAccountResponseModel>): void;
  createBankAccount(bankAccountRequest: Models.BankAccountRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.BankAccountResponseModel>): void;
  createBankAccount(bankAccountRequest: Models.BankAccountRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.BankAccountResponseModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.BankAccountResponseModel>;
    if (!callback) {
      return this.createBankAccountWithHttpOperationResponse(bankAccountRequest, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.BankAccountResponseModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createBankAccountWithHttpOperationResponse(bankAccountRequest, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.BankAccountResponseModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets the bin information for a specified credit card number.
   *
   * @param {BinRequestModel} binRequest The bin request.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.Bin} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.Bin} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getBin(binRequest: Models.BinRequestModel): Promise<Models.Bin>;
  getBin(binRequest: Models.BinRequestModel, options: msRest.RequestOptionsBase): Promise<Models.Bin>;
  getBin(binRequest: Models.BinRequestModel, callback: msRest.ServiceCallback<Models.Bin>): void;
  getBin(binRequest: Models.BinRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.Bin>): void;
  getBin(binRequest: Models.BinRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.Bin>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.Bin>;
    if (!callback) {
      return this.getBinWithHttpOperationResponse(binRequest, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.Bin);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getBinWithHttpOperationResponse(binRequest, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.Bin;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets the checkout.
   *
   * @param {number} checkoutId The checkout identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.CheckoutResponseModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.CheckoutResponseModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getCheckout(checkoutId: number): Promise<Models.CheckoutResponseModel>;
  getCheckout(checkoutId: number, options: msRest.RequestOptionsBase): Promise<Models.CheckoutResponseModel>;
  getCheckout(checkoutId: number, callback: msRest.ServiceCallback<Models.CheckoutResponseModel>): void;
  getCheckout(checkoutId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.CheckoutResponseModel>): void;
  getCheckout(checkoutId: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.CheckoutResponseModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.CheckoutResponseModel>;
    if (!callback) {
      return this.getCheckoutWithHttpOperationResponse(checkoutId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.CheckoutResponseModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getCheckoutWithHttpOperationResponse(checkoutId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.CheckoutResponseModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Posts the specified model.
   *
   * @param {CheckoutRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.CheckoutResponseModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.CheckoutResponseModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  createCheckout(model: Models.CheckoutRequestModel): Promise<Models.CheckoutResponseModel>;
  createCheckout(model: Models.CheckoutRequestModel, options: msRest.RequestOptionsBase): Promise<Models.CheckoutResponseModel>;
  createCheckout(model: Models.CheckoutRequestModel, callback: msRest.ServiceCallback<Models.CheckoutResponseModel>): void;
  createCheckout(model: Models.CheckoutRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.CheckoutResponseModel>): void;
  createCheckout(model: Models.CheckoutRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.CheckoutResponseModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.CheckoutResponseModel>;
    if (!callback) {
      return this.createCheckoutWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.CheckoutResponseModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createCheckoutWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.CheckoutResponseModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets all credit cards associated with the specified reference identifier.
   *
   * @param {string} referenceId The reference identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.CreditCardModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getCreditCardsByReferenceId(referenceId: string): Promise<Models.CreditCardModel[]>;
  getCreditCardsByReferenceId(referenceId: string, options: msRest.RequestOptionsBase): Promise<Models.CreditCardModel[]>;
  getCreditCardsByReferenceId(referenceId: string, callback: msRest.ServiceCallback<Models.CreditCardModel[]>): void;
  getCreditCardsByReferenceId(referenceId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.CreditCardModel[]>): void;
  getCreditCardsByReferenceId(referenceId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.CreditCardModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.CreditCardModel[]>;
    if (!callback) {
      return this.getCreditCardsByReferenceIdWithHttpOperationResponse(referenceId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.CreditCardModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getCreditCardsByReferenceIdWithHttpOperationResponse(referenceId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.CreditCardModel[];
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Updates a credit card.
   *
   * @param {UpdateCreditCardModel} updateCreditCardModel The update credit card model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  updateCreditCard(updateCreditCardModel: Models.UpdateCreditCardModel): Promise<void>;
  updateCreditCard(updateCreditCardModel: Models.UpdateCreditCardModel, options: msRest.RequestOptionsBase): Promise<void>;
  updateCreditCard(updateCreditCardModel: Models.UpdateCreditCardModel, callback: msRest.ServiceCallback<void>): void;
  updateCreditCard(updateCreditCardModel: Models.UpdateCreditCardModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  updateCreditCard(updateCreditCardModel: Models.UpdateCreditCardModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.updateCreditCardWithHttpOperationResponse(updateCreditCardModel, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateCreditCardWithHttpOperationResponse(updateCreditCardModel, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Posts a new credit card.
   *
   * @param {CreditCardRequestModel} creditCardRequest The new credit card.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.CreditCardResponseModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.CreditCardResponseModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  createCreditCard(creditCardRequest: Models.CreditCardRequestModel): Promise<Models.CreditCardResponseModel>;
  createCreditCard(creditCardRequest: Models.CreditCardRequestModel, options: msRest.RequestOptionsBase): Promise<Models.CreditCardResponseModel>;
  createCreditCard(creditCardRequest: Models.CreditCardRequestModel, callback: msRest.ServiceCallback<Models.CreditCardResponseModel>): void;
  createCreditCard(creditCardRequest: Models.CreditCardRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.CreditCardResponseModel>): void;
  createCreditCard(creditCardRequest: Models.CreditCardRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.CreditCardResponseModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.CreditCardResponseModel>;
    if (!callback) {
      return this.createCreditCardWithHttpOperationResponse(creditCardRequest, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.CreditCardResponseModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createCreditCardWithHttpOperationResponse(creditCardRequest, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.CreditCardResponseModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets the specified payment by its identifier.
   *
   * @param {number} id The payment identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.PaymentModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.PaymentModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getPayment(id: number): Promise<Models.PaymentModel>;
  getPayment(id: number, options: msRest.RequestOptionsBase): Promise<Models.PaymentModel>;
  getPayment(id: number, callback: msRest.ServiceCallback<Models.PaymentModel>): void;
  getPayment(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.PaymentModel>): void;
  getPayment(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.PaymentModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.PaymentModel>;
    if (!callback) {
      return this.getPaymentWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.PaymentModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getPaymentWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.PaymentModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets payments associated with the specified reference identifier.
   *
   * @param {SoftheonWalletAPIGetPaymentsByReferenceIdOptionalParams} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.PaymentModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getPaymentsByReferenceId(): Promise<Models.PaymentModel[]>;
  getPaymentsByReferenceId(options: Models.SoftheonWalletAPIGetPaymentsByReferenceIdOptionalParams): Promise<Models.PaymentModel[]>;
  getPaymentsByReferenceId(callback: msRest.ServiceCallback<Models.PaymentModel[]>): void;
  getPaymentsByReferenceId(options: Models.SoftheonWalletAPIGetPaymentsByReferenceIdOptionalParams, callback: msRest.ServiceCallback<Models.PaymentModel[]>): void;
  getPaymentsByReferenceId(options?: Models.SoftheonWalletAPIGetPaymentsByReferenceIdOptionalParams, callback?: msRest.ServiceCallback<Models.PaymentModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.PaymentModel[]>;
    if (!callback) {
      return this.getPaymentsByReferenceIdWithHttpOperationResponse(options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.PaymentModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getPaymentsByReferenceIdWithHttpOperationResponse(options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.PaymentModel[];
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Posts a new payment.
   *
   * @param {PaymentRequestModel} paymentRequest The new payment.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.PaymentModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.PaymentModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  createPayment(paymentRequest: Models.PaymentRequestModel): Promise<Models.PaymentModel>;
  createPayment(paymentRequest: Models.PaymentRequestModel, options: msRest.RequestOptionsBase): Promise<Models.PaymentModel>;
  createPayment(paymentRequest: Models.PaymentRequestModel, callback: msRest.ServiceCallback<Models.PaymentModel>): void;
  createPayment(paymentRequest: Models.PaymentRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.PaymentModel>): void;
  createPayment(paymentRequest: Models.PaymentRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.PaymentModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.PaymentModel>;
    if (!callback) {
      return this.createPaymentWithHttpOperationResponse(paymentRequest, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.PaymentModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createPaymentWithHttpOperationResponse(paymentRequest, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.PaymentModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets the refunds associated with the specified payment.
   *
   * @param {number} id The identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.RefundResultModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getRefunds(id: number): Promise<Models.RefundResultModel[]>;
  getRefunds(id: number, options: msRest.RequestOptionsBase): Promise<Models.RefundResultModel[]>;
  getRefunds(id: number, callback: msRest.ServiceCallback<Models.RefundResultModel[]>): void;
  getRefunds(id: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.RefundResultModel[]>): void;
  getRefunds(id: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.RefundResultModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.RefundResultModel[]>;
    if (!callback) {
      return this.getRefundsWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.RefundResultModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getRefundsWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.RefundResultModel[];
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Posts a new refund request.
   *
   * @param {number} id The identifier of the payment to be refunded.
   *
   * @param {RefundRequestModel} refundRequestModel The refund model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.RefundResultModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.RefundResultModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  createRefund(id: number, refundRequestModel: Models.RefundRequestModel): Promise<Models.RefundResultModel>;
  createRefund(id: number, refundRequestModel: Models.RefundRequestModel, options: msRest.RequestOptionsBase): Promise<Models.RefundResultModel>;
  createRefund(id: number, refundRequestModel: Models.RefundRequestModel, callback: msRest.ServiceCallback<Models.RefundResultModel>): void;
  createRefund(id: number, refundRequestModel: Models.RefundRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.RefundResultModel>): void;
  createRefund(id: number, refundRequestModel: Models.RefundRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.RefundResultModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.RefundResultModel>;
    if (!callback) {
      return this.createRefundWithHttpOperationResponse(id, refundRequestModel, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.RefundResultModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createRefundWithHttpOperationResponse(id, refundRequestModel, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.RefundResultModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets a single payment subscription with the specified subscription id.
   *
   * @param {string} id The subscription id.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.SubscriptionModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.SubscriptionModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getSubscription(id: string): Promise<Models.SubscriptionModel>;
  getSubscription(id: string, options: msRest.RequestOptionsBase): Promise<Models.SubscriptionModel>;
  getSubscription(id: string, callback: msRest.ServiceCallback<Models.SubscriptionModel>): void;
  getSubscription(id: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.SubscriptionModel>): void;
  getSubscription(id: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.SubscriptionModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.SubscriptionModel>;
    if (!callback) {
      return this.getSubscriptionWithHttpOperationResponse(id, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.SubscriptionModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getSubscriptionWithHttpOperationResponse(id, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.SubscriptionModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets all payment subscriptions associated with the specified reference id.
   *
   * @param {string} referenceId The reference identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.SubscriptionModel[]} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getSubscriptionsByReferenceId(referenceId: string): Promise<Models.SubscriptionModel[]>;
  getSubscriptionsByReferenceId(referenceId: string, options: msRest.RequestOptionsBase): Promise<Models.SubscriptionModel[]>;
  getSubscriptionsByReferenceId(referenceId: string, callback: msRest.ServiceCallback<Models.SubscriptionModel[]>): void;
  getSubscriptionsByReferenceId(referenceId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.SubscriptionModel[]>): void;
  getSubscriptionsByReferenceId(referenceId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.SubscriptionModel[]>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.SubscriptionModel[]>;
    if (!callback) {
      return this.getSubscriptionsByReferenceIdWithHttpOperationResponse(referenceId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.SubscriptionModel[]);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getSubscriptionsByReferenceIdWithHttpOperationResponse(referenceId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.SubscriptionModel[];
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Updates a payment subscription.
   *
   * @param {UpdateSubscriptionModel} updateSubscriptionModel The update subscription model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSubscription(updateSubscriptionModel: Models.UpdateSubscriptionModel): Promise<void>;
  updateSubscription(updateSubscriptionModel: Models.UpdateSubscriptionModel, options: msRest.RequestOptionsBase): Promise<void>;
  updateSubscription(updateSubscriptionModel: Models.UpdateSubscriptionModel, callback: msRest.ServiceCallback<void>): void;
  updateSubscription(updateSubscriptionModel: Models.UpdateSubscriptionModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  updateSubscription(updateSubscriptionModel: Models.UpdateSubscriptionModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.updateSubscriptionWithHttpOperationResponse(updateSubscriptionModel, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateSubscriptionWithHttpOperationResponse(updateSubscriptionModel, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Posts a new payment subscription.
   *
   * @param {SubscriptionRequestModel} subscriptionRequest The subscription request.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.SubscriptionResponseModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.SubscriptionResponseModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  createSubscription(subscriptionRequest: Models.SubscriptionRequestModel): Promise<Models.SubscriptionResponseModel>;
  createSubscription(subscriptionRequest: Models.SubscriptionRequestModel, options: msRest.RequestOptionsBase): Promise<Models.SubscriptionResponseModel>;
  createSubscription(subscriptionRequest: Models.SubscriptionRequestModel, callback: msRest.ServiceCallback<Models.SubscriptionResponseModel>): void;
  createSubscription(subscriptionRequest: Models.SubscriptionRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.SubscriptionResponseModel>): void;
  createSubscription(subscriptionRequest: Models.SubscriptionRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.SubscriptionResponseModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.SubscriptionResponseModel>;
    if (!callback) {
      return this.createSubscriptionWithHttpOperationResponse(subscriptionRequest, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.SubscriptionResponseModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createSubscriptionWithHttpOperationResponse(subscriptionRequest, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.SubscriptionResponseModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets the wallet by wallet ID
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.WalletModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.WalletModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getWallet(walletId: number): Promise<Models.WalletModel>;
  getWallet(walletId: number, options: msRest.RequestOptionsBase): Promise<Models.WalletModel>;
  getWallet(walletId: number, callback: msRest.ServiceCallback<Models.WalletModel>): void;
  getWallet(walletId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.WalletModel>): void;
  getWallet(walletId: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.WalletModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.WalletModel>;
    if (!callback) {
      return this.getWalletWithHttpOperationResponse(walletId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.WalletModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getWalletWithHttpOperationResponse(walletId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.WalletModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Puts the wallet.
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {string} defaultPaymentToken The default payment token.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  updateWallet(walletId: number, defaultPaymentToken: string): Promise<void>;
  updateWallet(walletId: number, defaultPaymentToken: string, options: msRest.RequestOptionsBase): Promise<void>;
  updateWallet(walletId: number, defaultPaymentToken: string, callback: msRest.ServiceCallback<void>): void;
  updateWallet(walletId: number, defaultPaymentToken: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  updateWallet(walletId: number, defaultPaymentToken: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.updateWalletWithHttpOperationResponse(walletId, defaultPaymentToken, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.updateWalletWithHttpOperationResponse(walletId, defaultPaymentToken, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Gets the wallet by reference ID
   *
   * @param {string} referenceId The reference identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.WalletModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.WalletModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  getWalletByReferenceId(referenceId: string): Promise<Models.WalletModel>;
  getWalletByReferenceId(referenceId: string, options: msRest.RequestOptionsBase): Promise<Models.WalletModel>;
  getWalletByReferenceId(referenceId: string, callback: msRest.ServiceCallback<Models.WalletModel>): void;
  getWalletByReferenceId(referenceId: string, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.WalletModel>): void;
  getWalletByReferenceId(referenceId: string, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.WalletModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.WalletModel>;
    if (!callback) {
      return this.getWalletByReferenceIdWithHttpOperationResponse(referenceId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.WalletModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.getWalletByReferenceIdWithHttpOperationResponse(referenceId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.WalletModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Creates a new empty wallet
   *
   * @param {WalletRequestModel} model The model.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {number} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  createWallet(model: Models.WalletRequestModel): Promise<number>;
  createWallet(model: Models.WalletRequestModel, options: msRest.RequestOptionsBase): Promise<number>;
  createWallet(model: Models.WalletRequestModel, callback: msRest.ServiceCallback<number>): void;
  createWallet(model: Models.WalletRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<number>): void;
  createWallet(model: Models.WalletRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<number>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<number>;
    if (!callback) {
      return this.createWalletWithHttpOperationResponse(model, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as number);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.createWalletWithHttpOperationResponse(model, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as number;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Adds a new credit card to the wallet
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {WalletCreditCardRequestModel} request The request.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.WalletModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.WalletModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  addWalletCreditCard(walletId: number, request: Models.WalletCreditCardRequestModel): Promise<Models.WalletModel>;
  addWalletCreditCard(walletId: number, request: Models.WalletCreditCardRequestModel, options: msRest.RequestOptionsBase): Promise<Models.WalletModel>;
  addWalletCreditCard(walletId: number, request: Models.WalletCreditCardRequestModel, callback: msRest.ServiceCallback<Models.WalletModel>): void;
  addWalletCreditCard(walletId: number, request: Models.WalletCreditCardRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.WalletModel>): void;
  addWalletCreditCard(walletId: number, request: Models.WalletCreditCardRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.WalletModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.WalletModel>;
    if (!callback) {
      return this.addWalletCreditCardWithHttpOperationResponse(walletId, request, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.WalletModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addWalletCreditCardWithHttpOperationResponse(walletId, request, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.WalletModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Adds a new bank account to the wallet
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {WalletBankAccountRequestModel} request The request.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {Models.WalletModel} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Models.WalletModel} for more information.
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  addWalletBankAccount(walletId: number, request: Models.WalletBankAccountRequestModel): Promise<Models.WalletModel>;
  addWalletBankAccount(walletId: number, request: Models.WalletBankAccountRequestModel, options: msRest.RequestOptionsBase): Promise<Models.WalletModel>;
  addWalletBankAccount(walletId: number, request: Models.WalletBankAccountRequestModel, callback: msRest.ServiceCallback<Models.WalletModel>): void;
  addWalletBankAccount(walletId: number, request: Models.WalletBankAccountRequestModel, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<Models.WalletModel>): void;
  addWalletBankAccount(walletId: number, request: Models.WalletBankAccountRequestModel, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<Models.WalletModel>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<Models.WalletModel>;
    if (!callback) {
      return this.addWalletBankAccountWithHttpOperationResponse(walletId, request, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as Models.WalletModel);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.addWalletBankAccountWithHttpOperationResponse(walletId, request, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as Models.WalletModel;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Deletes the wallet bank account.
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {number} walletBankAcctId The wallet bank acct identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  removeWalletBankAccount(walletId: number, walletBankAcctId: number): Promise<void>;
  removeWalletBankAccount(walletId: number, walletBankAcctId: number, options: msRest.RequestOptionsBase): Promise<void>;
  removeWalletBankAccount(walletId: number, walletBankAcctId: number, callback: msRest.ServiceCallback<void>): void;
  removeWalletBankAccount(walletId: number, walletBankAcctId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  removeWalletBankAccount(walletId: number, walletBankAcctId: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.removeWalletBankAccountWithHttpOperationResponse(walletId, walletBankAcctId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.removeWalletBankAccountWithHttpOperationResponse(walletId, walletBankAcctId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }

  /**
   * @summary Deletes the wallet credit card.
   *
   * @param {number} walletId The wallet identifier.
   *
   * @param {number} walletCreditCardId The wallet credit card identifier.
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @param {ServiceCallback} callback The callback.
   *
   * @returns {ServiceCallback} callback(err, result, request, operationRes)
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *                      {void} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *                      {HttpOperationResponse} [response] - The HTTP Response stream if an error did not occur.
   */
  removeWalletCreditCard(walletId: number, walletCreditCardId: number): Promise<void>;
  removeWalletCreditCard(walletId: number, walletCreditCardId: number, options: msRest.RequestOptionsBase): Promise<void>;
  removeWalletCreditCard(walletId: number, walletCreditCardId: number, callback: msRest.ServiceCallback<void>): void;
  removeWalletCreditCard(walletId: number, walletCreditCardId: number, options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  removeWalletCreditCard(walletId: number, walletCreditCardId: number, options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): any {
    if (!callback && typeof options === 'function') {
      callback = options;
      options = undefined;
    }
    let cb = callback as msRest.ServiceCallback<void>;
    if (!callback) {
      return this.removeWalletCreditCardWithHttpOperationResponse(walletId, walletCreditCardId, options).then((operationRes: msRest.HttpOperationResponse) => {
        return Promise.resolve(operationRes.parsedBody as void);
      }).catch((err: Error) => {
        return Promise.reject(err);
      });
    } else {
      msRest.promiseToCallback(this.removeWalletCreditCardWithHttpOperationResponse(walletId, walletCreditCardId, options))((err: Error, data: msRest.HttpOperationResponse) => {
        if (err) {
          return cb(err);
        }
        let result = data.parsedBody as void;
        return cb(err, result, data.request, data);
      });
    }
  }
}

export { SoftheonWalletAPI, Models as SoftheonWalletAPIModels, Mappers as SoftheonWalletAPIMappers };
