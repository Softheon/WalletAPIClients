/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package walletapiv2.implementation;

import .SoftheonWalletAPI;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import .models.BankAccountModel;
import .models.BankAccountRequestModel;
import .models.BankAccountResponseModel;
import .models.Bin;
import .models.BinRequestModel;
import .models.CheckoutRequestModel;
import .models.CheckoutResponseModel;
import .models.CreditCardModel;
import .models.CreditCardRequestModel;
import .models.CreditCardResponseModel;
import .models.PaymentModel;
import .models.PaymentRequestModel;
import .models.RefundRequestModel;
import .models.RefundResultModel;
import .models.SubscriptionModel;
import .models.SubscriptionRequestModel;
import .models.SubscriptionResponseModel;
import .models.UpdateBankAccountModel;
import .models.UpdateCreditCardModel;
import .models.UpdateSubscriptionModel;
import .models.WalletBankAccountRequestModel;
import .models.WalletCreditCardRequestModel;
import .models.WalletModel;
import .models.WalletRequestModel;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the SoftheonWalletAPI class.
 */
public class SoftheonWalletAPIImpl extends ServiceClient implements SoftheonWalletAPI {
    /**
     * The Retrofit service to perform REST calls.
     */
    private SoftheonWalletAPIService service;

    /**
     * Initializes an instance of SoftheonWalletAPI client.
     */
    public SoftheonWalletAPIImpl() {
        this("https://api-model.softheon.com/payments");
    }

    /**
     * Initializes an instance of SoftheonWalletAPI client.
     *
     * @param baseUrl the base URL of the host
     */
    public SoftheonWalletAPIImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of SoftheonWalletAPI client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public SoftheonWalletAPIImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https://api-model.softheon.com/payments", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of SoftheonWalletAPI client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public SoftheonWalletAPIImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of SoftheonWalletAPI client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public SoftheonWalletAPIImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(SoftheonWalletAPIService.class);
    }

    /**
     * The interface defining all the services for SoftheonWalletAPI to be
     * used by Retrofit to perform actually REST calls.
     */
    interface SoftheonWalletAPIService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getBankAccountByToken" })
        @GET("v2/bankaccounts/{token}")
        Observable<Response<ResponseBody>> getBankAccountByToken(@Path("token") String token);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getBankAccountsByReferenceId" })
        @GET("v2/bankaccounts")
        Observable<Response<ResponseBody>> getBankAccountsByReferenceId(@Query("referenceId") String referenceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI updateBankAccount" })
        @PUT("v2/bankaccounts")
        Observable<Response<ResponseBody>> updateBankAccount(@Body UpdateBankAccountModel updateBankAccountModel);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI createBankAccount" })
        @POST("v2/bankaccounts")
        Observable<Response<ResponseBody>> createBankAccount(@Body BankAccountRequestModel bankAccountRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getBin" })
        @POST("v2/bins")
        Observable<Response<ResponseBody>> getBin(@Body BinRequestModel binRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getCheckout" })
        @GET("v2/checkouts")
        Observable<Response<ResponseBody>> getCheckout(@Query("checkoutId") int checkoutId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI createCheckout" })
        @POST("v2/checkouts")
        Observable<Response<ResponseBody>> createCheckout(@Body CheckoutRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getCreditCardsByReferenceId" })
        @GET("v2/creditcards")
        Observable<Response<ResponseBody>> getCreditCardsByReferenceId(@Query("referenceId") String referenceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI updateCreditCard" })
        @PUT("v2/creditcards")
        Observable<Response<ResponseBody>> updateCreditCard(@Body UpdateCreditCardModel updateCreditCardModel);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI createCreditCard" })
        @POST("v2/creditcards")
        Observable<Response<ResponseBody>> createCreditCard(@Body CreditCardRequestModel creditCardRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getPayment" })
        @GET("v2/payments/{id}")
        Observable<Response<ResponseBody>> getPayment(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getPaymentsByReferenceId" })
        @GET("v2/payments")
        Observable<Response<ResponseBody>> getPaymentsByReferenceId(@Query("referenceId") String referenceId, @Query("minDate") DateTime minDate, @Query("maxDate") DateTime maxDate);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI createPayment" })
        @POST("v2/payments")
        Observable<Response<ResponseBody>> createPayment(@Body PaymentRequestModel paymentRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getRefunds" })
        @GET("v2/payments/{id}/refunds")
        Observable<Response<ResponseBody>> getRefunds(@Path("id") int id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI createRefund" })
        @POST("v2/payments/{id}/refunds")
        Observable<Response<ResponseBody>> createRefund(@Path("id") int id, @Body RefundRequestModel refundRequestModel);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getSubscription" })
        @GET("v2/subscriptions/{id}")
        Observable<Response<ResponseBody>> getSubscription(@Path("id") String id);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getSubscriptionsByReferenceId" })
        @GET("v2/subscriptions")
        Observable<Response<ResponseBody>> getSubscriptionsByReferenceId(@Query("referenceId") String referenceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI updateSubscription" })
        @PUT("v2/subscriptions")
        Observable<Response<ResponseBody>> updateSubscription(@Body UpdateSubscriptionModel updateSubscriptionModel);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI createSubscription" })
        @POST("v2/subscriptions")
        Observable<Response<ResponseBody>> createSubscription(@Body SubscriptionRequestModel subscriptionRequest);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getWallet" })
        @GET("v2/wallet/{walletId}")
        Observable<Response<ResponseBody>> getWallet(@Path("walletId") int walletId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI updateWallet" })
        @PUT("v2/wallet/{walletId}")
        Observable<Response<ResponseBody>> updateWallet(@Path("walletId") int walletId, @Body String defaultPaymentToken);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI getWalletByReferenceId" })
        @GET("v2/wallet")
        Observable<Response<ResponseBody>> getWalletByReferenceId(@Query("referenceId") String referenceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI createWallet" })
        @POST("v2/wallet")
        Observable<Response<ResponseBody>> createWallet(@Body WalletRequestModel model);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI addWalletCreditCard" })
        @POST("v2/wallet/{walletId}/CreditCard")
        Observable<Response<ResponseBody>> addWalletCreditCard(@Path("walletId") int walletId, @Body WalletCreditCardRequestModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI addWalletBankAccount" })
        @POST("v2/wallet/{walletId}/BankAccount")
        Observable<Response<ResponseBody>> addWalletBankAccount(@Path("walletId") int walletId, @Body WalletBankAccountRequestModel request);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI removeWalletBankAccount" })
        @HTTP(path = "v2/wallet/{walletId}/BankAccount/{walletBankAcctId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> removeWalletBankAccount(@Path("walletId") int walletId, @Path("walletBankAcctId") int walletBankAcctId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: .SoftheonWalletAPI removeWalletCreditCard" })
        @HTTP(path = "v2/wallet/{walletId}/CreditCard/{walletCreditCardId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> removeWalletCreditCard(@Path("walletId") int walletId, @Path("walletCreditCardId") int walletCreditCardId);

    }

    /**
     * Gets the bank account associated with the specified token.
     *
     * @param token The token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BankAccountModel object if successful.
     */
    public BankAccountModel getBankAccountByToken(String token) {
        return getBankAccountByTokenWithServiceResponseAsync(token).toBlocking().single().body();
    }

    /**
     * Gets the bank account associated with the specified token.
     *
     * @param token The token.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BankAccountModel> getBankAccountByTokenAsync(String token, final ServiceCallback<BankAccountModel> serviceCallback) {
        return ServiceFuture.fromResponse(getBankAccountByTokenWithServiceResponseAsync(token), serviceCallback);
    }

    /**
     * Gets the bank account associated with the specified token.
     *
     * @param token The token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BankAccountModel object
     */
    public Observable<BankAccountModel> getBankAccountByTokenAsync(String token) {
        return getBankAccountByTokenWithServiceResponseAsync(token).map(new Func1<ServiceResponse<BankAccountModel>, BankAccountModel>() {
            @Override
            public BankAccountModel call(ServiceResponse<BankAccountModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the bank account associated with the specified token.
     *
     * @param token The token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BankAccountModel object
     */
    public Observable<ServiceResponse<BankAccountModel>> getBankAccountByTokenWithServiceResponseAsync(String token) {
        if (token == null) {
            throw new IllegalArgumentException("Parameter token is required and cannot be null.");
        }
        return service.getBankAccountByToken(token)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BankAccountModel>>>() {
                @Override
                public Observable<ServiceResponse<BankAccountModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BankAccountModel> clientResponse = getBankAccountByTokenDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BankAccountModel> getBankAccountByTokenDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BankAccountModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BankAccountModel>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets all bank accounts associated with the specified reference identifier.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;BankAccountModel&gt; object if successful.
     */
    public List<BankAccountModel> getBankAccountsByReferenceId(String referenceId) {
        return getBankAccountsByReferenceIdWithServiceResponseAsync(referenceId).toBlocking().single().body();
    }

    /**
     * Gets all bank accounts associated with the specified reference identifier.
     *
     * @param referenceId The reference identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<BankAccountModel>> getBankAccountsByReferenceIdAsync(String referenceId, final ServiceCallback<List<BankAccountModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getBankAccountsByReferenceIdWithServiceResponseAsync(referenceId), serviceCallback);
    }

    /**
     * Gets all bank accounts associated with the specified reference identifier.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;BankAccountModel&gt; object
     */
    public Observable<List<BankAccountModel>> getBankAccountsByReferenceIdAsync(String referenceId) {
        return getBankAccountsByReferenceIdWithServiceResponseAsync(referenceId).map(new Func1<ServiceResponse<List<BankAccountModel>>, List<BankAccountModel>>() {
            @Override
            public List<BankAccountModel> call(ServiceResponse<List<BankAccountModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all bank accounts associated with the specified reference identifier.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;BankAccountModel&gt; object
     */
    public Observable<ServiceResponse<List<BankAccountModel>>> getBankAccountsByReferenceIdWithServiceResponseAsync(String referenceId) {
        if (referenceId == null) {
            throw new IllegalArgumentException("Parameter referenceId is required and cannot be null.");
        }
        return service.getBankAccountsByReferenceId(referenceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<BankAccountModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<BankAccountModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<BankAccountModel>> clientResponse = getBankAccountsByReferenceIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<BankAccountModel>> getBankAccountsByReferenceIdDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<BankAccountModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<BankAccountModel>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a bank account.
     *
     * @param updateBankAccountModel The update bank account model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateBankAccount(UpdateBankAccountModel updateBankAccountModel) {
        updateBankAccountWithServiceResponseAsync(updateBankAccountModel).toBlocking().single().body();
    }

    /**
     * Updates a bank account.
     *
     * @param updateBankAccountModel The update bank account model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateBankAccountAsync(UpdateBankAccountModel updateBankAccountModel, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateBankAccountWithServiceResponseAsync(updateBankAccountModel), serviceCallback);
    }

    /**
     * Updates a bank account.
     *
     * @param updateBankAccountModel The update bank account model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateBankAccountAsync(UpdateBankAccountModel updateBankAccountModel) {
        return updateBankAccountWithServiceResponseAsync(updateBankAccountModel).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a bank account.
     *
     * @param updateBankAccountModel The update bank account model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateBankAccountWithServiceResponseAsync(UpdateBankAccountModel updateBankAccountModel) {
        if (updateBankAccountModel == null) {
            throw new IllegalArgumentException("Parameter updateBankAccountModel is required and cannot be null.");
        }
        Validator.validate(updateBankAccountModel);
        return service.updateBankAccount(updateBankAccountModel)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateBankAccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateBankAccountDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Posts a new bank account.
     *
     * @param bankAccountRequest The bank account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the BankAccountResponseModel object if successful.
     */
    public BankAccountResponseModel createBankAccount(BankAccountRequestModel bankAccountRequest) {
        return createBankAccountWithServiceResponseAsync(bankAccountRequest).toBlocking().single().body();
    }

    /**
     * Posts a new bank account.
     *
     * @param bankAccountRequest The bank account.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<BankAccountResponseModel> createBankAccountAsync(BankAccountRequestModel bankAccountRequest, final ServiceCallback<BankAccountResponseModel> serviceCallback) {
        return ServiceFuture.fromResponse(createBankAccountWithServiceResponseAsync(bankAccountRequest), serviceCallback);
    }

    /**
     * Posts a new bank account.
     *
     * @param bankAccountRequest The bank account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BankAccountResponseModel object
     */
    public Observable<BankAccountResponseModel> createBankAccountAsync(BankAccountRequestModel bankAccountRequest) {
        return createBankAccountWithServiceResponseAsync(bankAccountRequest).map(new Func1<ServiceResponse<BankAccountResponseModel>, BankAccountResponseModel>() {
            @Override
            public BankAccountResponseModel call(ServiceResponse<BankAccountResponseModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Posts a new bank account.
     *
     * @param bankAccountRequest The bank account.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the BankAccountResponseModel object
     */
    public Observable<ServiceResponse<BankAccountResponseModel>> createBankAccountWithServiceResponseAsync(BankAccountRequestModel bankAccountRequest) {
        if (bankAccountRequest == null) {
            throw new IllegalArgumentException("Parameter bankAccountRequest is required and cannot be null.");
        }
        Validator.validate(bankAccountRequest);
        return service.createBankAccount(bankAccountRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BankAccountResponseModel>>>() {
                @Override
                public Observable<ServiceResponse<BankAccountResponseModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BankAccountResponseModel> clientResponse = createBankAccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BankAccountResponseModel> createBankAccountDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<BankAccountResponseModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<BankAccountResponseModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets the bin information for a specified credit card number.
     *
     * @param binRequest The bin request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Bin object if successful.
     */
    public Bin getBin(BinRequestModel binRequest) {
        return getBinWithServiceResponseAsync(binRequest).toBlocking().single().body();
    }

    /**
     * Gets the bin information for a specified credit card number.
     *
     * @param binRequest The bin request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Bin> getBinAsync(BinRequestModel binRequest, final ServiceCallback<Bin> serviceCallback) {
        return ServiceFuture.fromResponse(getBinWithServiceResponseAsync(binRequest), serviceCallback);
    }

    /**
     * Gets the bin information for a specified credit card number.
     *
     * @param binRequest The bin request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Bin object
     */
    public Observable<Bin> getBinAsync(BinRequestModel binRequest) {
        return getBinWithServiceResponseAsync(binRequest).map(new Func1<ServiceResponse<Bin>, Bin>() {
            @Override
            public Bin call(ServiceResponse<Bin> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the bin information for a specified credit card number.
     *
     * @param binRequest The bin request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Bin object
     */
    public Observable<ServiceResponse<Bin>> getBinWithServiceResponseAsync(BinRequestModel binRequest) {
        if (binRequest == null) {
            throw new IllegalArgumentException("Parameter binRequest is required and cannot be null.");
        }
        Validator.validate(binRequest);
        return service.getBin(binRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Bin>>>() {
                @Override
                public Observable<ServiceResponse<Bin>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Bin> clientResponse = getBinDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Bin> getBinDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Bin, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Bin>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets the checkout.
     *
     * @param checkoutId The checkout identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CheckoutResponseModel object if successful.
     */
    public CheckoutResponseModel getCheckout(int checkoutId) {
        return getCheckoutWithServiceResponseAsync(checkoutId).toBlocking().single().body();
    }

    /**
     * Gets the checkout.
     *
     * @param checkoutId The checkout identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CheckoutResponseModel> getCheckoutAsync(int checkoutId, final ServiceCallback<CheckoutResponseModel> serviceCallback) {
        return ServiceFuture.fromResponse(getCheckoutWithServiceResponseAsync(checkoutId), serviceCallback);
    }

    /**
     * Gets the checkout.
     *
     * @param checkoutId The checkout identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CheckoutResponseModel object
     */
    public Observable<CheckoutResponseModel> getCheckoutAsync(int checkoutId) {
        return getCheckoutWithServiceResponseAsync(checkoutId).map(new Func1<ServiceResponse<CheckoutResponseModel>, CheckoutResponseModel>() {
            @Override
            public CheckoutResponseModel call(ServiceResponse<CheckoutResponseModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the checkout.
     *
     * @param checkoutId The checkout identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CheckoutResponseModel object
     */
    public Observable<ServiceResponse<CheckoutResponseModel>> getCheckoutWithServiceResponseAsync(int checkoutId) {
        return service.getCheckout(checkoutId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CheckoutResponseModel>>>() {
                @Override
                public Observable<ServiceResponse<CheckoutResponseModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CheckoutResponseModel> clientResponse = getCheckoutDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CheckoutResponseModel> getCheckoutDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<CheckoutResponseModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<CheckoutResponseModel>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Posts the specified model.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CheckoutResponseModel object if successful.
     */
    public CheckoutResponseModel createCheckout(CheckoutRequestModel model) {
        return createCheckoutWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Posts the specified model.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CheckoutResponseModel> createCheckoutAsync(CheckoutRequestModel model, final ServiceCallback<CheckoutResponseModel> serviceCallback) {
        return ServiceFuture.fromResponse(createCheckoutWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Posts the specified model.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CheckoutResponseModel object
     */
    public Observable<CheckoutResponseModel> createCheckoutAsync(CheckoutRequestModel model) {
        return createCheckoutWithServiceResponseAsync(model).map(new Func1<ServiceResponse<CheckoutResponseModel>, CheckoutResponseModel>() {
            @Override
            public CheckoutResponseModel call(ServiceResponse<CheckoutResponseModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Posts the specified model.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CheckoutResponseModel object
     */
    public Observable<ServiceResponse<CheckoutResponseModel>> createCheckoutWithServiceResponseAsync(CheckoutRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createCheckout(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CheckoutResponseModel>>>() {
                @Override
                public Observable<ServiceResponse<CheckoutResponseModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CheckoutResponseModel> clientResponse = createCheckoutDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CheckoutResponseModel> createCheckoutDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<CheckoutResponseModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<CheckoutResponseModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets all credit cards associated with the specified reference identifier.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;CreditCardModel&gt; object if successful.
     */
    public List<CreditCardModel> getCreditCardsByReferenceId(String referenceId) {
        return getCreditCardsByReferenceIdWithServiceResponseAsync(referenceId).toBlocking().single().body();
    }

    /**
     * Gets all credit cards associated with the specified reference identifier.
     *
     * @param referenceId The reference identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<CreditCardModel>> getCreditCardsByReferenceIdAsync(String referenceId, final ServiceCallback<List<CreditCardModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getCreditCardsByReferenceIdWithServiceResponseAsync(referenceId), serviceCallback);
    }

    /**
     * Gets all credit cards associated with the specified reference identifier.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CreditCardModel&gt; object
     */
    public Observable<List<CreditCardModel>> getCreditCardsByReferenceIdAsync(String referenceId) {
        return getCreditCardsByReferenceIdWithServiceResponseAsync(referenceId).map(new Func1<ServiceResponse<List<CreditCardModel>>, List<CreditCardModel>>() {
            @Override
            public List<CreditCardModel> call(ServiceResponse<List<CreditCardModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all credit cards associated with the specified reference identifier.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;CreditCardModel&gt; object
     */
    public Observable<ServiceResponse<List<CreditCardModel>>> getCreditCardsByReferenceIdWithServiceResponseAsync(String referenceId) {
        if (referenceId == null) {
            throw new IllegalArgumentException("Parameter referenceId is required and cannot be null.");
        }
        return service.getCreditCardsByReferenceId(referenceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<CreditCardModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<CreditCardModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<CreditCardModel>> clientResponse = getCreditCardsByReferenceIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<CreditCardModel>> getCreditCardsByReferenceIdDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<CreditCardModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<CreditCardModel>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a credit card.
     *
     * @param updateCreditCardModel The update credit card model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateCreditCard(UpdateCreditCardModel updateCreditCardModel) {
        updateCreditCardWithServiceResponseAsync(updateCreditCardModel).toBlocking().single().body();
    }

    /**
     * Updates a credit card.
     *
     * @param updateCreditCardModel The update credit card model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateCreditCardAsync(UpdateCreditCardModel updateCreditCardModel, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateCreditCardWithServiceResponseAsync(updateCreditCardModel), serviceCallback);
    }

    /**
     * Updates a credit card.
     *
     * @param updateCreditCardModel The update credit card model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateCreditCardAsync(UpdateCreditCardModel updateCreditCardModel) {
        return updateCreditCardWithServiceResponseAsync(updateCreditCardModel).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a credit card.
     *
     * @param updateCreditCardModel The update credit card model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateCreditCardWithServiceResponseAsync(UpdateCreditCardModel updateCreditCardModel) {
        if (updateCreditCardModel == null) {
            throw new IllegalArgumentException("Parameter updateCreditCardModel is required and cannot be null.");
        }
        Validator.validate(updateCreditCardModel);
        return service.updateCreditCard(updateCreditCardModel)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateCreditCardDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateCreditCardDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Posts a new credit card.
     *
     * @param creditCardRequest The new credit card.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the CreditCardResponseModel object if successful.
     */
    public CreditCardResponseModel createCreditCard(CreditCardRequestModel creditCardRequest) {
        return createCreditCardWithServiceResponseAsync(creditCardRequest).toBlocking().single().body();
    }

    /**
     * Posts a new credit card.
     *
     * @param creditCardRequest The new credit card.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<CreditCardResponseModel> createCreditCardAsync(CreditCardRequestModel creditCardRequest, final ServiceCallback<CreditCardResponseModel> serviceCallback) {
        return ServiceFuture.fromResponse(createCreditCardWithServiceResponseAsync(creditCardRequest), serviceCallback);
    }

    /**
     * Posts a new credit card.
     *
     * @param creditCardRequest The new credit card.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CreditCardResponseModel object
     */
    public Observable<CreditCardResponseModel> createCreditCardAsync(CreditCardRequestModel creditCardRequest) {
        return createCreditCardWithServiceResponseAsync(creditCardRequest).map(new Func1<ServiceResponse<CreditCardResponseModel>, CreditCardResponseModel>() {
            @Override
            public CreditCardResponseModel call(ServiceResponse<CreditCardResponseModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Posts a new credit card.
     *
     * @param creditCardRequest The new credit card.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the CreditCardResponseModel object
     */
    public Observable<ServiceResponse<CreditCardResponseModel>> createCreditCardWithServiceResponseAsync(CreditCardRequestModel creditCardRequest) {
        if (creditCardRequest == null) {
            throw new IllegalArgumentException("Parameter creditCardRequest is required and cannot be null.");
        }
        Validator.validate(creditCardRequest);
        return service.createCreditCard(creditCardRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CreditCardResponseModel>>>() {
                @Override
                public Observable<ServiceResponse<CreditCardResponseModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<CreditCardResponseModel> clientResponse = createCreditCardDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<CreditCardResponseModel> createCreditCardDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<CreditCardResponseModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<CreditCardResponseModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets the specified payment by its identifier.
     *
     * @param id The payment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PaymentModel object if successful.
     */
    public PaymentModel getPayment(int id) {
        return getPaymentWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the specified payment by its identifier.
     *
     * @param id The payment identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PaymentModel> getPaymentAsync(int id, final ServiceCallback<PaymentModel> serviceCallback) {
        return ServiceFuture.fromResponse(getPaymentWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the specified payment by its identifier.
     *
     * @param id The payment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PaymentModel object
     */
    public Observable<PaymentModel> getPaymentAsync(int id) {
        return getPaymentWithServiceResponseAsync(id).map(new Func1<ServiceResponse<PaymentModel>, PaymentModel>() {
            @Override
            public PaymentModel call(ServiceResponse<PaymentModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the specified payment by its identifier.
     *
     * @param id The payment identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PaymentModel object
     */
    public Observable<ServiceResponse<PaymentModel>> getPaymentWithServiceResponseAsync(int id) {
        return service.getPayment(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PaymentModel>>>() {
                @Override
                public Observable<ServiceResponse<PaymentModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PaymentModel> clientResponse = getPaymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PaymentModel> getPaymentDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<PaymentModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<PaymentModel>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets payments associated with the specified reference identifier.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PaymentModel&gt; object if successful.
     */
    public List<PaymentModel> getPaymentsByReferenceId() {
        return getPaymentsByReferenceIdWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Gets payments associated with the specified reference identifier.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PaymentModel>> getPaymentsByReferenceIdAsync(final ServiceCallback<List<PaymentModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getPaymentsByReferenceIdWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Gets payments associated with the specified reference identifier.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PaymentModel&gt; object
     */
    public Observable<List<PaymentModel>> getPaymentsByReferenceIdAsync() {
        return getPaymentsByReferenceIdWithServiceResponseAsync().map(new Func1<ServiceResponse<List<PaymentModel>>, List<PaymentModel>>() {
            @Override
            public List<PaymentModel> call(ServiceResponse<List<PaymentModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets payments associated with the specified reference identifier.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PaymentModel&gt; object
     */
    public Observable<ServiceResponse<List<PaymentModel>>> getPaymentsByReferenceIdWithServiceResponseAsync() {
        final String referenceId = null;
        final DateTime minDate = null;
        final DateTime maxDate = null;
        return service.getPaymentsByReferenceId(referenceId, minDate, maxDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PaymentModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<PaymentModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PaymentModel>> clientResponse = getPaymentsByReferenceIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Gets payments associated with the specified reference identifier.
     *
     * @param referenceId Gets or sets the reference identifier.
     * @param minDate Gets or sets the minimum date.
     * @param maxDate Gets or sets the maximum date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;PaymentModel&gt; object if successful.
     */
    public List<PaymentModel> getPaymentsByReferenceId(String referenceId, DateTime minDate, DateTime maxDate) {
        return getPaymentsByReferenceIdWithServiceResponseAsync(referenceId, minDate, maxDate).toBlocking().single().body();
    }

    /**
     * Gets payments associated with the specified reference identifier.
     *
     * @param referenceId Gets or sets the reference identifier.
     * @param minDate Gets or sets the minimum date.
     * @param maxDate Gets or sets the maximum date.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<PaymentModel>> getPaymentsByReferenceIdAsync(String referenceId, DateTime minDate, DateTime maxDate, final ServiceCallback<List<PaymentModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getPaymentsByReferenceIdWithServiceResponseAsync(referenceId, minDate, maxDate), serviceCallback);
    }

    /**
     * Gets payments associated with the specified reference identifier.
     *
     * @param referenceId Gets or sets the reference identifier.
     * @param minDate Gets or sets the minimum date.
     * @param maxDate Gets or sets the maximum date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PaymentModel&gt; object
     */
    public Observable<List<PaymentModel>> getPaymentsByReferenceIdAsync(String referenceId, DateTime minDate, DateTime maxDate) {
        return getPaymentsByReferenceIdWithServiceResponseAsync(referenceId, minDate, maxDate).map(new Func1<ServiceResponse<List<PaymentModel>>, List<PaymentModel>>() {
            @Override
            public List<PaymentModel> call(ServiceResponse<List<PaymentModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets payments associated with the specified reference identifier.
     *
     * @param referenceId Gets or sets the reference identifier.
     * @param minDate Gets or sets the minimum date.
     * @param maxDate Gets or sets the maximum date.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;PaymentModel&gt; object
     */
    public Observable<ServiceResponse<List<PaymentModel>>> getPaymentsByReferenceIdWithServiceResponseAsync(String referenceId, DateTime minDate, DateTime maxDate) {
        return service.getPaymentsByReferenceId(referenceId, minDate, maxDate)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<PaymentModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<PaymentModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<PaymentModel>> clientResponse = getPaymentsByReferenceIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<PaymentModel>> getPaymentsByReferenceIdDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<PaymentModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<PaymentModel>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Posts a new payment.
     *
     * @param paymentRequest The new payment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the PaymentModel object if successful.
     */
    public PaymentModel createPayment(PaymentRequestModel paymentRequest) {
        return createPaymentWithServiceResponseAsync(paymentRequest).toBlocking().single().body();
    }

    /**
     * Posts a new payment.
     *
     * @param paymentRequest The new payment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<PaymentModel> createPaymentAsync(PaymentRequestModel paymentRequest, final ServiceCallback<PaymentModel> serviceCallback) {
        return ServiceFuture.fromResponse(createPaymentWithServiceResponseAsync(paymentRequest), serviceCallback);
    }

    /**
     * Posts a new payment.
     *
     * @param paymentRequest The new payment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PaymentModel object
     */
    public Observable<PaymentModel> createPaymentAsync(PaymentRequestModel paymentRequest) {
        return createPaymentWithServiceResponseAsync(paymentRequest).map(new Func1<ServiceResponse<PaymentModel>, PaymentModel>() {
            @Override
            public PaymentModel call(ServiceResponse<PaymentModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Posts a new payment.
     *
     * @param paymentRequest The new payment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the PaymentModel object
     */
    public Observable<ServiceResponse<PaymentModel>> createPaymentWithServiceResponseAsync(PaymentRequestModel paymentRequest) {
        if (paymentRequest == null) {
            throw new IllegalArgumentException("Parameter paymentRequest is required and cannot be null.");
        }
        Validator.validate(paymentRequest);
        return service.createPayment(paymentRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<PaymentModel>>>() {
                @Override
                public Observable<ServiceResponse<PaymentModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PaymentModel> clientResponse = createPaymentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<PaymentModel> createPaymentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<PaymentModel, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<PaymentModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets the refunds associated with the specified payment.
     *
     * @param id The identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RefundResultModel&gt; object if successful.
     */
    public List<RefundResultModel> getRefunds(int id) {
        return getRefundsWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets the refunds associated with the specified payment.
     *
     * @param id The identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RefundResultModel>> getRefundsAsync(int id, final ServiceCallback<List<RefundResultModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getRefundsWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets the refunds associated with the specified payment.
     *
     * @param id The identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RefundResultModel&gt; object
     */
    public Observable<List<RefundResultModel>> getRefundsAsync(int id) {
        return getRefundsWithServiceResponseAsync(id).map(new Func1<ServiceResponse<List<RefundResultModel>>, List<RefundResultModel>>() {
            @Override
            public List<RefundResultModel> call(ServiceResponse<List<RefundResultModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the refunds associated with the specified payment.
     *
     * @param id The identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RefundResultModel&gt; object
     */
    public Observable<ServiceResponse<List<RefundResultModel>>> getRefundsWithServiceResponseAsync(int id) {
        return service.getRefunds(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<RefundResultModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<RefundResultModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<RefundResultModel>> clientResponse = getRefundsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<RefundResultModel>> getRefundsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<List<RefundResultModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RefundResultModel>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Posts a new refund request.
     *
     * @param id The identifier of the payment to be refunded.
     * @param refundRequestModel The refund model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RefundResultModel object if successful.
     */
    public RefundResultModel createRefund(int id, RefundRequestModel refundRequestModel) {
        return createRefundWithServiceResponseAsync(id, refundRequestModel).toBlocking().single().body();
    }

    /**
     * Posts a new refund request.
     *
     * @param id The identifier of the payment to be refunded.
     * @param refundRequestModel The refund model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RefundResultModel> createRefundAsync(int id, RefundRequestModel refundRequestModel, final ServiceCallback<RefundResultModel> serviceCallback) {
        return ServiceFuture.fromResponse(createRefundWithServiceResponseAsync(id, refundRequestModel), serviceCallback);
    }

    /**
     * Posts a new refund request.
     *
     * @param id The identifier of the payment to be refunded.
     * @param refundRequestModel The refund model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RefundResultModel object
     */
    public Observable<RefundResultModel> createRefundAsync(int id, RefundRequestModel refundRequestModel) {
        return createRefundWithServiceResponseAsync(id, refundRequestModel).map(new Func1<ServiceResponse<RefundResultModel>, RefundResultModel>() {
            @Override
            public RefundResultModel call(ServiceResponse<RefundResultModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Posts a new refund request.
     *
     * @param id The identifier of the payment to be refunded.
     * @param refundRequestModel The refund model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RefundResultModel object
     */
    public Observable<ServiceResponse<RefundResultModel>> createRefundWithServiceResponseAsync(int id, RefundRequestModel refundRequestModel) {
        if (refundRequestModel == null) {
            throw new IllegalArgumentException("Parameter refundRequestModel is required and cannot be null.");
        }
        Validator.validate(refundRequestModel);
        return service.createRefund(id, refundRequestModel)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RefundResultModel>>>() {
                @Override
                public Observable<ServiceResponse<RefundResultModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RefundResultModel> clientResponse = createRefundDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<RefundResultModel> createRefundDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RefundResultModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RefundResultModel>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets a single payment subscription with the specified subscription id.
     *
     * @param id The subscription id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionModel object if successful.
     */
    public SubscriptionModel getSubscription(String id) {
        return getSubscriptionWithServiceResponseAsync(id).toBlocking().single().body();
    }

    /**
     * Gets a single payment subscription with the specified subscription id.
     *
     * @param id The subscription id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionModel> getSubscriptionAsync(String id, final ServiceCallback<SubscriptionModel> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionWithServiceResponseAsync(id), serviceCallback);
    }

    /**
     * Gets a single payment subscription with the specified subscription id.
     *
     * @param id The subscription id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionModel object
     */
    public Observable<SubscriptionModel> getSubscriptionAsync(String id) {
        return getSubscriptionWithServiceResponseAsync(id).map(new Func1<ServiceResponse<SubscriptionModel>, SubscriptionModel>() {
            @Override
            public SubscriptionModel call(ServiceResponse<SubscriptionModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets a single payment subscription with the specified subscription id.
     *
     * @param id The subscription id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionModel object
     */
    public Observable<ServiceResponse<SubscriptionModel>> getSubscriptionWithServiceResponseAsync(String id) {
        if (id == null) {
            throw new IllegalArgumentException("Parameter id is required and cannot be null.");
        }
        return service.getSubscription(id)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SubscriptionModel>>>() {
                @Override
                public Observable<ServiceResponse<SubscriptionModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SubscriptionModel> clientResponse = getSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SubscriptionModel> getSubscriptionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SubscriptionModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SubscriptionModel>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets all payment subscriptions associated with the specified reference id.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;SubscriptionModel&gt; object if successful.
     */
    public List<SubscriptionModel> getSubscriptionsByReferenceId(String referenceId) {
        return getSubscriptionsByReferenceIdWithServiceResponseAsync(referenceId).toBlocking().single().body();
    }

    /**
     * Gets all payment subscriptions associated with the specified reference id.
     *
     * @param referenceId The reference identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<SubscriptionModel>> getSubscriptionsByReferenceIdAsync(String referenceId, final ServiceCallback<List<SubscriptionModel>> serviceCallback) {
        return ServiceFuture.fromResponse(getSubscriptionsByReferenceIdWithServiceResponseAsync(referenceId), serviceCallback);
    }

    /**
     * Gets all payment subscriptions associated with the specified reference id.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SubscriptionModel&gt; object
     */
    public Observable<List<SubscriptionModel>> getSubscriptionsByReferenceIdAsync(String referenceId) {
        return getSubscriptionsByReferenceIdWithServiceResponseAsync(referenceId).map(new Func1<ServiceResponse<List<SubscriptionModel>>, List<SubscriptionModel>>() {
            @Override
            public List<SubscriptionModel> call(ServiceResponse<List<SubscriptionModel>> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets all payment subscriptions associated with the specified reference id.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;SubscriptionModel&gt; object
     */
    public Observable<ServiceResponse<List<SubscriptionModel>>> getSubscriptionsByReferenceIdWithServiceResponseAsync(String referenceId) {
        if (referenceId == null) {
            throw new IllegalArgumentException("Parameter referenceId is required and cannot be null.");
        }
        return service.getSubscriptionsByReferenceId(referenceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<SubscriptionModel>>>>() {
                @Override
                public Observable<ServiceResponse<List<SubscriptionModel>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<SubscriptionModel>> clientResponse = getSubscriptionsByReferenceIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<SubscriptionModel>> getSubscriptionsByReferenceIdDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<SubscriptionModel>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<SubscriptionModel>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Updates a payment subscription.
     *
     * @param updateSubscriptionModel The update subscription model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateSubscription(UpdateSubscriptionModel updateSubscriptionModel) {
        updateSubscriptionWithServiceResponseAsync(updateSubscriptionModel).toBlocking().single().body();
    }

    /**
     * Updates a payment subscription.
     *
     * @param updateSubscriptionModel The update subscription model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateSubscriptionAsync(UpdateSubscriptionModel updateSubscriptionModel, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateSubscriptionWithServiceResponseAsync(updateSubscriptionModel), serviceCallback);
    }

    /**
     * Updates a payment subscription.
     *
     * @param updateSubscriptionModel The update subscription model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateSubscriptionAsync(UpdateSubscriptionModel updateSubscriptionModel) {
        return updateSubscriptionWithServiceResponseAsync(updateSubscriptionModel).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates a payment subscription.
     *
     * @param updateSubscriptionModel The update subscription model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateSubscriptionWithServiceResponseAsync(UpdateSubscriptionModel updateSubscriptionModel) {
        if (updateSubscriptionModel == null) {
            throw new IllegalArgumentException("Parameter updateSubscriptionModel is required and cannot be null.");
        }
        Validator.validate(updateSubscriptionModel);
        return service.updateSubscription(updateSubscriptionModel)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateSubscriptionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Posts a new payment subscription.
     *
     * @param subscriptionRequest The subscription request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the SubscriptionResponseModel object if successful.
     */
    public SubscriptionResponseModel createSubscription(SubscriptionRequestModel subscriptionRequest) {
        return createSubscriptionWithServiceResponseAsync(subscriptionRequest).toBlocking().single().body();
    }

    /**
     * Posts a new payment subscription.
     *
     * @param subscriptionRequest The subscription request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<SubscriptionResponseModel> createSubscriptionAsync(SubscriptionRequestModel subscriptionRequest, final ServiceCallback<SubscriptionResponseModel> serviceCallback) {
        return ServiceFuture.fromResponse(createSubscriptionWithServiceResponseAsync(subscriptionRequest), serviceCallback);
    }

    /**
     * Posts a new payment subscription.
     *
     * @param subscriptionRequest The subscription request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionResponseModel object
     */
    public Observable<SubscriptionResponseModel> createSubscriptionAsync(SubscriptionRequestModel subscriptionRequest) {
        return createSubscriptionWithServiceResponseAsync(subscriptionRequest).map(new Func1<ServiceResponse<SubscriptionResponseModel>, SubscriptionResponseModel>() {
            @Override
            public SubscriptionResponseModel call(ServiceResponse<SubscriptionResponseModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Posts a new payment subscription.
     *
     * @param subscriptionRequest The subscription request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the SubscriptionResponseModel object
     */
    public Observable<ServiceResponse<SubscriptionResponseModel>> createSubscriptionWithServiceResponseAsync(SubscriptionRequestModel subscriptionRequest) {
        if (subscriptionRequest == null) {
            throw new IllegalArgumentException("Parameter subscriptionRequest is required and cannot be null.");
        }
        Validator.validate(subscriptionRequest);
        return service.createSubscription(subscriptionRequest)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<SubscriptionResponseModel>>>() {
                @Override
                public Observable<ServiceResponse<SubscriptionResponseModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<SubscriptionResponseModel> clientResponse = createSubscriptionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<SubscriptionResponseModel> createSubscriptionDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<SubscriptionResponseModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SubscriptionResponseModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets the wallet by wallet ID.
     *
     * @param walletId The wallet identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WalletModel object if successful.
     */
    public WalletModel getWallet(int walletId) {
        return getWalletWithServiceResponseAsync(walletId).toBlocking().single().body();
    }

    /**
     * Gets the wallet by wallet ID.
     *
     * @param walletId The wallet identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WalletModel> getWalletAsync(int walletId, final ServiceCallback<WalletModel> serviceCallback) {
        return ServiceFuture.fromResponse(getWalletWithServiceResponseAsync(walletId), serviceCallback);
    }

    /**
     * Gets the wallet by wallet ID.
     *
     * @param walletId The wallet identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WalletModel object
     */
    public Observable<WalletModel> getWalletAsync(int walletId) {
        return getWalletWithServiceResponseAsync(walletId).map(new Func1<ServiceResponse<WalletModel>, WalletModel>() {
            @Override
            public WalletModel call(ServiceResponse<WalletModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the wallet by wallet ID.
     *
     * @param walletId The wallet identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WalletModel object
     */
    public Observable<ServiceResponse<WalletModel>> getWalletWithServiceResponseAsync(int walletId) {
        return service.getWallet(walletId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WalletModel>>>() {
                @Override
                public Observable<ServiceResponse<WalletModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WalletModel> clientResponse = getWalletDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WalletModel> getWalletDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<WalletModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WalletModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Puts the wallet.
     *
     * @param walletId The wallet identifier.
     * @param defaultPaymentToken The default payment token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void updateWallet(int walletId, String defaultPaymentToken) {
        updateWalletWithServiceResponseAsync(walletId, defaultPaymentToken).toBlocking().single().body();
    }

    /**
     * Puts the wallet.
     *
     * @param walletId The wallet identifier.
     * @param defaultPaymentToken The default payment token.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> updateWalletAsync(int walletId, String defaultPaymentToken, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(updateWalletWithServiceResponseAsync(walletId, defaultPaymentToken), serviceCallback);
    }

    /**
     * Puts the wallet.
     *
     * @param walletId The wallet identifier.
     * @param defaultPaymentToken The default payment token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> updateWalletAsync(int walletId, String defaultPaymentToken) {
        return updateWalletWithServiceResponseAsync(walletId, defaultPaymentToken).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Puts the wallet.
     *
     * @param walletId The wallet identifier.
     * @param defaultPaymentToken The default payment token.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> updateWalletWithServiceResponseAsync(int walletId, String defaultPaymentToken) {
        if (defaultPaymentToken == null) {
            throw new IllegalArgumentException("Parameter defaultPaymentToken is required and cannot be null.");
        }
        return service.updateWallet(walletId, defaultPaymentToken)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = updateWalletDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> updateWalletDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Gets the wallet by reference ID.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WalletModel object if successful.
     */
    public WalletModel getWalletByReferenceId(String referenceId) {
        return getWalletByReferenceIdWithServiceResponseAsync(referenceId).toBlocking().single().body();
    }

    /**
     * Gets the wallet by reference ID.
     *
     * @param referenceId The reference identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WalletModel> getWalletByReferenceIdAsync(String referenceId, final ServiceCallback<WalletModel> serviceCallback) {
        return ServiceFuture.fromResponse(getWalletByReferenceIdWithServiceResponseAsync(referenceId), serviceCallback);
    }

    /**
     * Gets the wallet by reference ID.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WalletModel object
     */
    public Observable<WalletModel> getWalletByReferenceIdAsync(String referenceId) {
        return getWalletByReferenceIdWithServiceResponseAsync(referenceId).map(new Func1<ServiceResponse<WalletModel>, WalletModel>() {
            @Override
            public WalletModel call(ServiceResponse<WalletModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the wallet by reference ID.
     *
     * @param referenceId The reference identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WalletModel object
     */
    public Observable<ServiceResponse<WalletModel>> getWalletByReferenceIdWithServiceResponseAsync(String referenceId) {
        if (referenceId == null) {
            throw new IllegalArgumentException("Parameter referenceId is required and cannot be null.");
        }
        return service.getWalletByReferenceId(referenceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WalletModel>>>() {
                @Override
                public Observable<ServiceResponse<WalletModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WalletModel> clientResponse = getWalletByReferenceIdDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WalletModel> getWalletByReferenceIdDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<WalletModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WalletModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Creates a new empty wallet.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the int object if successful.
     */
    public int createWallet(WalletRequestModel model) {
        return createWalletWithServiceResponseAsync(model).toBlocking().single().body();
    }

    /**
     * Creates a new empty wallet.
     *
     * @param model The model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Integer> createWalletAsync(WalletRequestModel model, final ServiceCallback<Integer> serviceCallback) {
        return ServiceFuture.fromResponse(createWalletWithServiceResponseAsync(model), serviceCallback);
    }

    /**
     * Creates a new empty wallet.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<Integer> createWalletAsync(WalletRequestModel model) {
        return createWalletWithServiceResponseAsync(model).map(new Func1<ServiceResponse<Integer>, Integer>() {
            @Override
            public Integer call(ServiceResponse<Integer> response) {
                return response.body();
            }
        });
    }

    /**
     * Creates a new empty wallet.
     *
     * @param model The model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Integer object
     */
    public Observable<ServiceResponse<Integer>> createWalletWithServiceResponseAsync(WalletRequestModel model) {
        if (model == null) {
            throw new IllegalArgumentException("Parameter model is required and cannot be null.");
        }
        Validator.validate(model);
        return service.createWallet(model)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Integer>>>() {
                @Override
                public Observable<ServiceResponse<Integer>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Integer> clientResponse = createWalletDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Integer> createWalletDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Integer, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Integer>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Adds a new credit card to the wallet.
     *
     * @param walletId The wallet identifier.
     * @param request The request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WalletModel object if successful.
     */
    public WalletModel addWalletCreditCard(int walletId, WalletCreditCardRequestModel request) {
        return addWalletCreditCardWithServiceResponseAsync(walletId, request).toBlocking().single().body();
    }

    /**
     * Adds a new credit card to the wallet.
     *
     * @param walletId The wallet identifier.
     * @param request The request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WalletModel> addWalletCreditCardAsync(int walletId, WalletCreditCardRequestModel request, final ServiceCallback<WalletModel> serviceCallback) {
        return ServiceFuture.fromResponse(addWalletCreditCardWithServiceResponseAsync(walletId, request), serviceCallback);
    }

    /**
     * Adds a new credit card to the wallet.
     *
     * @param walletId The wallet identifier.
     * @param request The request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WalletModel object
     */
    public Observable<WalletModel> addWalletCreditCardAsync(int walletId, WalletCreditCardRequestModel request) {
        return addWalletCreditCardWithServiceResponseAsync(walletId, request).map(new Func1<ServiceResponse<WalletModel>, WalletModel>() {
            @Override
            public WalletModel call(ServiceResponse<WalletModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a new credit card to the wallet.
     *
     * @param walletId The wallet identifier.
     * @param request The request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WalletModel object
     */
    public Observable<ServiceResponse<WalletModel>> addWalletCreditCardWithServiceResponseAsync(int walletId, WalletCreditCardRequestModel request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.addWalletCreditCard(walletId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WalletModel>>>() {
                @Override
                public Observable<ServiceResponse<WalletModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WalletModel> clientResponse = addWalletCreditCardDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WalletModel> addWalletCreditCardDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<WalletModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WalletModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Adds a new bank account to the wallet.
     *
     * @param walletId The wallet identifier.
     * @param request The request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the WalletModel object if successful.
     */
    public WalletModel addWalletBankAccount(int walletId, WalletBankAccountRequestModel request) {
        return addWalletBankAccountWithServiceResponseAsync(walletId, request).toBlocking().single().body();
    }

    /**
     * Adds a new bank account to the wallet.
     *
     * @param walletId The wallet identifier.
     * @param request The request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<WalletModel> addWalletBankAccountAsync(int walletId, WalletBankAccountRequestModel request, final ServiceCallback<WalletModel> serviceCallback) {
        return ServiceFuture.fromResponse(addWalletBankAccountWithServiceResponseAsync(walletId, request), serviceCallback);
    }

    /**
     * Adds a new bank account to the wallet.
     *
     * @param walletId The wallet identifier.
     * @param request The request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WalletModel object
     */
    public Observable<WalletModel> addWalletBankAccountAsync(int walletId, WalletBankAccountRequestModel request) {
        return addWalletBankAccountWithServiceResponseAsync(walletId, request).map(new Func1<ServiceResponse<WalletModel>, WalletModel>() {
            @Override
            public WalletModel call(ServiceResponse<WalletModel> response) {
                return response.body();
            }
        });
    }

    /**
     * Adds a new bank account to the wallet.
     *
     * @param walletId The wallet identifier.
     * @param request The request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the WalletModel object
     */
    public Observable<ServiceResponse<WalletModel>> addWalletBankAccountWithServiceResponseAsync(int walletId, WalletBankAccountRequestModel request) {
        if (request == null) {
            throw new IllegalArgumentException("Parameter request is required and cannot be null.");
        }
        Validator.validate(request);
        return service.addWalletBankAccount(walletId, request)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<WalletModel>>>() {
                @Override
                public Observable<ServiceResponse<WalletModel>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<WalletModel> clientResponse = addWalletBankAccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<WalletModel> addWalletBankAccountDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<WalletModel, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WalletModel>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes the wallet bank account.
     *
     * @param walletId The wallet identifier.
     * @param walletBankAcctId The wallet bank acct identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeWalletBankAccount(int walletId, int walletBankAcctId) {
        removeWalletBankAccountWithServiceResponseAsync(walletId, walletBankAcctId).toBlocking().single().body();
    }

    /**
     * Deletes the wallet bank account.
     *
     * @param walletId The wallet identifier.
     * @param walletBankAcctId The wallet bank acct identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeWalletBankAccountAsync(int walletId, int walletBankAcctId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeWalletBankAccountWithServiceResponseAsync(walletId, walletBankAcctId), serviceCallback);
    }

    /**
     * Deletes the wallet bank account.
     *
     * @param walletId The wallet identifier.
     * @param walletBankAcctId The wallet bank acct identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeWalletBankAccountAsync(int walletId, int walletBankAcctId) {
        return removeWalletBankAccountWithServiceResponseAsync(walletId, walletBankAcctId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the wallet bank account.
     *
     * @param walletId The wallet identifier.
     * @param walletBankAcctId The wallet bank acct identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeWalletBankAccountWithServiceResponseAsync(int walletId, int walletBankAcctId) {
        return service.removeWalletBankAccount(walletId, walletBankAcctId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeWalletBankAccountDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> removeWalletBankAccountDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

    /**
     * Deletes the wallet credit card.
     *
     * @param walletId The wallet identifier.
     * @param walletCreditCardId The wallet credit card identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void removeWalletCreditCard(int walletId, int walletCreditCardId) {
        removeWalletCreditCardWithServiceResponseAsync(walletId, walletCreditCardId).toBlocking().single().body();
    }

    /**
     * Deletes the wallet credit card.
     *
     * @param walletId The wallet identifier.
     * @param walletCreditCardId The wallet credit card identifier.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> removeWalletCreditCardAsync(int walletId, int walletCreditCardId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(removeWalletCreditCardWithServiceResponseAsync(walletId, walletCreditCardId), serviceCallback);
    }

    /**
     * Deletes the wallet credit card.
     *
     * @param walletId The wallet identifier.
     * @param walletCreditCardId The wallet credit card identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> removeWalletCreditCardAsync(int walletId, int walletCreditCardId) {
        return removeWalletCreditCardWithServiceResponseAsync(walletId, walletCreditCardId).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Deletes the wallet credit card.
     *
     * @param walletId The wallet identifier.
     * @param walletCreditCardId The wallet credit card identifier.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> removeWalletCreditCardWithServiceResponseAsync(int walletId, int walletCreditCardId) {
        return service.removeWalletCreditCard(walletId, walletCreditCardId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = removeWalletCreditCardDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> removeWalletCreditCardDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(400, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .build(response);
    }

}
